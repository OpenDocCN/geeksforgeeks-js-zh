# JavaScript 中事件循环内的微任务和宏任务是什么？

> 原文:[https://www . geesforgeks . org/什么是 javascript 中的事件循环中的微任务和宏任务/](https://www.geeksforgeeks.org/what-are-the-microtask-and-macrotask-within-an-event-loop-in-javascript/)

**事件循环:**JavaScript 中的事件循环被认为是一个持续运行的进程，它在调用栈中保持一个标签。它的主要功能是检查调用栈是否为空。如果调用堆栈为空，事件循环将继续执行任务队列中等待的所有回调。在任务队列中，任务大致分为两类，即微观任务和宏观任务。

**事件循环内的微任务:**微任务被认为是在创建它的函数或程序退出之后并且仅当 JavaScript 执行堆栈为空时，但在将控制返回给用户代理用来驱动脚本执行环境的事件循环之前执行的函数。微任务也能够对其他微任务进行排队。

微任务通常被安排在需要在当前脚本执行后立即完成的事情上。在一个宏任务完成后，事件循环转移到微任务队列。在微任务队列中的所有任务完成之前，事件循环不会移动到微任务队列之外的下一个任务。这意味着微任务队列具有更高的优先级。

一旦微任务队列中的所有任务都完成了，事件循环才会转移回宏任务队列。对微任务队列进行优先级排序的主要原因是为了改善用户体验。在回调之后处理微任务队列，假设任何其他 JavaScript 没有处于中间执行状态。微任务包括突变观察者回调以及承诺回调。

在新的微任务被添加到队列中的这种情况下，这些附加的微任务被添加到微队列的末尾，并且这些也被处理。这是因为事件循环将继续调用微任务，直到队列中没有更多的微任务，即使新任务不断被添加。使用微任务的另一个重要原因是确保任务的顺序一致，同时降低用户造成延迟的风险。

**语法:**添加微任务:

```
queueMicrotask(() => {
    // Code to be run inside the micro-task 
});

```

微任务函数本身没有参数，也不返回值。

**示例:** process.nextTick，Promises，queueMicrotask，MutationObserver

**事件循环内的宏任务:**宏任务代表一些离散的、独立的工作。这些总是 JavaScript 代码的执行，微任务队列是空的。宏任务队列通常被认为与任务队列或事件队列相同。但是，宏任务队列的工作方式与任务队列相同。两者之间唯一的小区别是任务队列用于同步语句，而宏任务队列用于异步语句。

在 JavaScript 中，在事件发生之前，不允许执行任何代码。{值得一提的是，执行一个 JavaScript 代码执行本身就是一个宏任务。}事件作为宏任务排队。当宏任务队列中的(宏)任务正在执行时，可以注册新的事件，并依次创建和添加到队列中。

初始化时，JavaScript 引擎首先完成宏任务队列中的第一个任务，并执行回调处理程序。然后，JavaScript 引擎将这些异步函数发送到 API 模块，该模块在适当的时候将它们推送到宏任务队列。一旦进入宏任务队列，每个宏任务都需要等待下一轮事件循环。这样，代码就被执行了。

所有记录的微任务都在一个宏任务执行周期中一次性处理。相比之下，宏任务队列的优先级较低。宏任务包括解析 HTML、生成 DOM、执行主线程 JavaScript 代码等事件，如页面加载、输入、网络事件、定时器事件等。

**示例:**设置超时、设置间隔、设置立即、请求动画帧、输入/输出、用户界面渲染